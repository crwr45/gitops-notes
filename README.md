# gitops-notes

Notes and process discovered while setting up OpenShift GitOps on top of a post-Crucible cluster.

## Console access

At time of writing Crucible does not output the password for the `kubeadmin` user, so logging into the console is not immediately easy. The password can be obtained through the Assisted Installer user interface, or changed to a known value using the provided kubeconfig as shown [here](https://blog.andyserver.com/2021/07/rotating-the-openshift-kubeadmin-password/).

Log in to the web console. The console URL can be found with the command 

```bash
oc whoami --show-console
```

## Installing OpenShift GitOps

Install the GitOps operator by adding a subscription to the cluser:

```bash
oc apply -f gitops_subscription.yml
```

```yaml
# gitops_subscription.yml
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-gitops-operator
  namespace: openshift-operators
spec:
  channel: stable
  installPlanApproval: Automatic
  name: openshift-gitops-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
```

This will install the Operator, which will then automatically create the `openshift-gitops` namespace and set up an ArgoCD instance. You can watch for pods coming up with the following command:

```bash
oc get pods -n openshift-gitops
```


## OpenShift GitOps Certificate

The Web UI is not required (OpenShift GitOps provides functionality to manage ArgoCD on the cluster through the OpenShift API) but is very useful for monitoring and debugging in this discovery stage. If needed, the URL of the installed ArgoCD can be found with this command:

```bash
oc get route openshift-gitops-server -n openshift-gitops -o jsonpath='{.spec.host}{"\n"}'
```

A bare, post-Crucible, cluster has its own self-signed certificate, but the OpenShift GitOps Operator does not configure the included ArgoCD to use this and, while a certificate is generated, it is not used by ArgoCD without some extra steps. This means that the URL of the ArgoCD Instance may be inaccessible until a valid certificate configuration is set up. Detailed instruction on how to do this can be found on [access.redhat.com](https://access.redhat.com/solutions/6041341). Either configure the ArgoCD `Route` for `edge` termination so it will use HTTP within the cluster, or modify the configuration to actually use the certificate generated by the operator.

At this point the OpenShift GitOps-installed ArgoCD web GUI should be accessible.

## Configuring RBAC for OpenShift GitOps

The `ServiceAccount` that is used by ArgoCD (`serviceaccount/openshift-gitops-argocd-application-controller`) to make changes to the cluster is not made a cluster Admin by default. This means that it will need to be given permissions to take whatever actions are required. The easiest way to do this for now is to create a `ClusterRoleBinding` to give the `ServiceAccount` full cluster Admin priviledges.

```yaml
# gitops_cluster_admin.yml
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: gitops-cluster-admin
subjects:
  - kind: ServiceAccount
    name: openshift-gitops-argocd-application-controller
    namespace: openshift-gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: admin
```

This approach needs to be revisited with a more secure option when this process is being automated and refined for production environments if possible. Ideally the cluster Admin role should be restricted to namespaces that ArgoCD needs to control.


## Using OpenShift GitOps

At this point OpenShift GitOps `Application` resources can be created. This will cause the OpenShift GitOps operator to enter the app into ArgoCD, which will be responsible for synchronising the repository state into the target cluster. The target cluster does NOT need to be the cluster running OpenShift GitOps


### OpenShift Namespace

By default OpenShift GitOps will only load resources from the `openshift-gitops` namespace. I did not try hard to find a method to make it load from other namespaces, but for complex use cases where it is being used to manage multiple other clusters it is advisable to have separate namespaces for each cluster being managed.

### ArgoCD Projects

An ArgoCD `Project` MUST be created prior to being mentioned in an `Application` resource. An example can be found [here](manifests/pao/nova_project.yml).
The `Project` provides enforcement within ArgoCD itself for which repositories are allowed to be pulled, clusters and namespaces that can be targetted.

**Both the included `default` project and the example `nova_project.yml` are maximally permissive.**
